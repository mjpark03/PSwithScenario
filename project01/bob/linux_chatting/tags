!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BACKSPACE	chatting.cpp	8;"	d	file:
BACKSPACE_INPUT	chatting.cpp	7;"	d	file:
BEGIN_X_POS	src/terminal.cpp	/^const static unsigned int BEGIN_X_POS = 1;$/;"	v	file:
CacheValue	include/lfu_cache.h	/^	CacheValue() {}$/;"	f	class:CacheValue
CacheValue	include/lfu_cache.h	/^	CacheValue(vector<string> value, KeyNode *node) : value(value), count(1), node(node){}$/;"	f	class:CacheValue
CacheValue	include/lfu_cache.h	/^class CacheValue {$/;"	c
Cursor	include/terminal.h	/^typedef struct Cursor {$/;"	s
Doubly_Llinked	include/lfu_cache.h	/^class Doubly_Llinked {$/;"	c
END_INPUT	chatting.cpp	9;"	d	file:
KeyNode	include/lfu_cache.h	/^	KeyNode(int key) : key(key), prev(NULL), next(NULL) {}$/;"	f	class:KeyNode
KeyNode	include/lfu_cache.h	/^class KeyNode {$/;"	c
LFUCache	include/lfu_cache.h	/^	LFUCache(int capacity) : lfuNode(NULL), capacity(capacity) {}$/;"	f	class:LFUCache
LFUCache	include/lfu_cache.h	/^class LFUCache {$/;"	c
MAP_CAT	include/lfu_cache.h	/^	enum MAP_CAT{$/;"	g	class:LFUCache
MAP_CAT_NODE	include/lfu_cache.h	/^		MAP_CAT_NODE,$/;"	e	enum:LFUCache::MAP_CAT
MAP_CAT_VALUE	include/lfu_cache.h	/^		MAP_CAT_VALUE$/;"	e	enum:LFUCache::MAP_CAT
NEW_LINE	chatting.cpp	10;"	d	file:
PROMPT_ID	src/terminal.cpp	7;"	d	file:
QUIT_NOTI	src/terminal.cpp	8;"	d	file:
TERMINAL_X_SIZE	src/terminal.cpp	5;"	d	file:
TERMINAL_Y_SIZE	src/terminal.cpp	6;"	d	file:
TerminalPrinter	include/terminal.h	/^class TerminalPrinter {$/;"	c
TerminalPrinter	src/terminal.cpp	/^TerminalPrinter::TerminalPrinter() :$/;"	f	class:TerminalPrinter
__LFU_CACHE__	include/lfu_cache.h	2;"	d
__TERMINAL__	include/terminal.h	2;"	d
add_before	src/lfu_cache.cpp	/^void Doubly_Llinked::add_before(KeyNode *std, KeyNode *newBefore) {$/;"	f	class:Doubly_Llinked
add_next	src/lfu_cache.cpp	/^void Doubly_Llinked::add_next(KeyNode *std, KeyNode *newNext) {$/;"	f	class:Doubly_Llinked
auto_words_y_pos	include/terminal.h	/^    unsigned int auto_words_y_pos;$/;"	m	struct:Cursor
capacity	include/lfu_cache.h	/^	size_t capacity;$/;"	m	class:LFUCache
chat_last_y_pos	include/terminal.h	/^    unsigned int chat_last_y_pos;$/;"	m	struct:Cursor
clear	src/terminal.cpp	/^void TerminalPrinter::clear() {$/;"	f	class:TerminalPrinter
clear_line	src/terminal.cpp	/^void TerminalPrinter::clear_line() {$/;"	f	class:TerminalPrinter
count	include/lfu_cache.h	/^	int count;$/;"	m	class:CacheValue
cursor	include/terminal.h	/^        cursor_t cursor;$/;"	m	class:TerminalPrinter
cursor_t	include/terminal.h	/^} cursor_t;$/;"	t	typeref:struct:Cursor
distract	src/lfu_cache.cpp	/^void Doubly_Llinked::distract(KeyNode *std) {$/;"	f	class:Doubly_Llinked
dll	include/lfu_cache.h	/^	Doubly_Llinked dll;$/;"	m	class:LFUCache
doesMapHaveKey	src/lfu_cache.cpp	/^bool LFUCache::doesMapHaveKey(int key, MAP_CAT cat) {$/;"	f	class:LFUCache
get	src/lfu_cache.cpp	/^vector<string> LFUCache::get(int key) {$/;"	f	class:LFUCache
get_string_words	src/terminal.cpp	/^vector<string> get_string_words(string buf) {$/;"	f
input_last_x_pos	include/terminal.h	/^    unsigned int input_last_x_pos;$/;"	m	struct:Cursor
input_y_pos	include/terminal.h	/^    unsigned int input_y_pos;$/;"	m	struct:Cursor
isCountEqualMapValueCount	src/lfu_cache.cpp	/^bool LFUCache::isCountEqualMapValueCount(int key, int count) {$/;"	f	class:LFUCache
isKeyEqualMapNodeKey	src/lfu_cache.cpp	/^bool LFUCache::isKeyEqualMapNodeKey(int count, int key) {$/;"	f	class:LFUCache
isLfuNodeCountLessThanNextNodeCount	src/lfu_cache.cpp	/^bool LFUCache::isLfuNodeCountLessThanNextNodeCount(KeyNode *node, int count) {$/;"	f	class:LFUCache
isMapValueFull	src/lfu_cache.cpp	/^bool LFUCache::isMapValueFull() {$/;"	f	class:LFUCache
isNodeEqualLfuNode	src/lfu_cache.cpp	/^bool LFUCache::isNodeEqualLfuNode(KeyNode *node) {$/;"	f	class:LFUCache
isNodeEqualMapNode	src/lfu_cache.cpp	/^bool LFUCache::isNodeEqualMapNode(KeyNode *node, int count) {$/;"	f	class:LFUCache
key	include/lfu_cache.h	/^	int key;$/;"	m	class:KeyNode
lc	include/terminal.h	/^        LFUCache *lc;$/;"	m	class:TerminalPrinter
lfuNode	include/lfu_cache.h	/^	KeyNode *lfuNode;$/;"	m	class:LFUCache
listen	src/terminal.cpp	/^void TerminalPrinter::listen() {$/;"	f	class:TerminalPrinter
main	chatting.cpp	/^int main(void)$/;"	f
main	src/client.cpp	/^int main()$/;"	f
main	src/server.cpp	/^int main()$/;"	f
map_node	include/lfu_cache.h	/^	unordered_map<int, KeyNode*> map_node;$/;"	m	class:LFUCache
map_value	include/lfu_cache.h	/^	unordered_map<int, CacheValue> map_value;$/;"	m	class:LFUCache
next	include/lfu_cache.h	/^	KeyNode *next;$/;"	m	class:KeyNode
node	include/lfu_cache.h	/^	KeyNode *node;$/;"	m	class:CacheValue
prev	include/lfu_cache.h	/^	KeyNode *prev;$/;"	m	class:KeyNode
print	src/terminal.cpp	/^void TerminalPrinter::print(string buf) {$/;"	f	class:TerminalPrinter
prompt_id	include/terminal.h	/^        string prompt_id;$/;"	m	class:TerminalPrinter
put	src/lfu_cache.cpp	/^void LFUCache::put(int key, string value) {$/;"	f	class:LFUCache
set_cursor	src/terminal.cpp	/^void TerminalPrinter::set_cursor(int x, int y) {$/;"	f	class:TerminalPrinter
set_input_mode	src/terminal.cpp	/^void TerminalPrinter::set_input_mode() {$/;"	f	class:TerminalPrinter
show_input_words	src/terminal.cpp	/^void TerminalPrinter::show_input_words(char ch) {$/;"	f	class:TerminalPrinter
value	include/lfu_cache.h	/^	vector<string> value;$/;"	m	class:CacheValue
